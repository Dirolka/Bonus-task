## String Algorithm Project – KMP in Java

### 1. Goal

The goal of this work is to implement a classic string matching algorithm in Java and see how it behaves on different input sizes. I chose the Knuth–Morris–Pratt (KMP) algorithm because it is more efficient than the naive method and is often used as a basic example of linear‑time pattern matching.

The program finds all occurrences of a pattern inside a text and demonstrates the algorithm on three test cases (short, medium and long strings). The results are written into the file `output.txt`.

### 2. KMP algorithm idea

We want to find a pattern `P` of length `m` in a text `T` of length `n`. The naive algorithm may compare the same characters many times and in the worst case works in `O(n * m)` time.

KMP avoids this by preprocessing the pattern. It builds an array `lps` (“longest proper prefix which is also suffix”). For each position `i` in the pattern, `lps[i]` stores the length of the longest prefix of `P` that is also a suffix of `P[0..i]`.  

During the search, when a mismatch happens after some characters matched, we do not go back in the text. Instead, we move the pattern index according to `lps` and continue the comparison. This way every character of the text is processed only a constant number of times.

### 3. Implementation ([KMP.java](cci:7://file:///c:/Users/yadis/IdeaProjects/untitled6/src/main/java/org/example/KMP.java:0:0-0:0))

All code is in [KMP.java](cci:7://file:///c:/Users/yadis/IdeaProjects/untitled6/src/main/java/org/example/KMP.java:0:0-0:0) (package `org.example`).

- [buildLps(String pattern)](cci:1://file:///c:/Users/yadis/IdeaProjects/untitled6/src/main/java/org/example/KMP.java:9:4-29:5)  
  Builds the `lps` array in one pass over the pattern using two indices: current position `i` and current prefix–suffix length `len`.

- [searchAll(String text, String pattern)](cci:1://file:///c:/Users/yadis/IdeaProjects/untitled6/src/main/java/org/example/KMP.java:11:4-44:5)  
  Uses KMP to find **all** occurrences of the pattern in the text. It returns a list of starting indices. Two indices are used: `i` for the text and `j` for the pattern. On match, both move forward; when `j` reaches `m`, we store `i - j` as a match and update `j` via `lps`. On mismatch, `j` either moves back using `lps`, or we advance `i` if nothing matches.

- [positionsToString(List<Integer> pos)](cci:1://file:///c:/Users/yadis/IdeaProjects/untitled6/src/main/java/org/example/KMP.java:46:4-58:5)  
  Converts the list of indices to a comma‑separated string (or `"No occurrences"` if the list is empty).

- [main(String[] args)](cci:1://file:///c:/Users/yadis/IdeaProjects/untitled6/src/main/java/org/example/Main.java:8:4-40:39)  
  Creates three test examples and writes formatted results to `src/main/java/org/example/output.txt` using `FileWriter` and `PrintWriter`.

### 4. Test cases

1. **Short test**  
   Text: `uhozhusdfauuhozhus`  
   Pattern: `uhozhu`  
   Small example to check correctness by hand.

2. **Medium test**  
   Text: `gffggggfgfggggfggg`  
   Pattern: `fggg`  
   Contains several (possibly overlapping) matches, useful to verify that the algorithm does not miss them.

3. **Long test**  
   A long text is generated by repeating a short block many times using `StringBuilder`. Then a pattern (for example `cab`) is searched in this long string. The program prints the length of the text, the pattern, the number of occurrences and some sample positions (first and last indices).

All results are written to `output.txt`, which can be opened after the program finishes.

### 5. Complexity

The complexity of KMP can be divided into two parts:

- **Preprocessing ([buildLps](cci:1://file:///c:/Users/yadis/IdeaProjects/untitled6/src/main/java/org/example/KMP.java:9:4-29:5))** – the pattern is processed once.  
  Time: `O(m)`  
  Memory: `O(m)` for the `lps` array.

- **Search ([searchAll](cci:1://file:///c:/Users/yadis/IdeaProjects/untitled6/src/main/java/org/example/KMP.java:11:4-44:5))** – we scan the text without moving the text index backwards.  
  Time: `O(n)`  

So the overall time complexity of this implementation is **`O(n + m)`**, which is better than the naive **`O(n * m)`**. The extra memory usage is **`O(m)`**.

### 6. Conclusion

In this project I implemented the Knuth–Morris–Pratt algorithm in Java and tested it on short, medium and long strings. The implementation correctly finds all occurrences of a pattern and shows that the running time grows linearly with the size of the text when using KMP.